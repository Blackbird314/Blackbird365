+++
title = "Rust 核心语法：所有权与借用"
date = "2024-05-21T18:19:51+08:00"
tags = ["Rust"]
description = "但是，古尔丹，代价是什么呢？"
slug = "rust-ownership"
+++

所有编程语言都无法回避一个问题：内存管理。我们往往希望编程语言有两个特点：

- 内存对象能在正确的时机及时释放，这使我们能控制程序的内存消耗
- 在内存对象被释放后，不应该继续使用指向它的指针，这会导致崩溃和安全漏洞

由此诞生出两个阵营：1)以 C/C++/Zig 为代表，手动管理内存的申请和释放，但避免内存泄漏和悬空指针是程序员的责任。2)依靠垃圾回收机制(Garbage Collection)自动管理，在所有指向内存对象的指针都消失后，自动释放对应内存。但这会影响程序性能，几乎所有现代编程语言，包括 Java/Python/Go/Haskell 都在此列。

为了同时兼顾安全与性能，Rust 选择了第三种方式：由编译器管理内存，即编译时就决定何时释放内存并写入可执行程序。这样既不会影响运行时性能，也可以保证内存安全和并发安全（Rust 无法完全避免内存泄漏，但至少大大降低了内存泄漏的可能，这是后话）。

为了满足要求，Rust 语言提出了两个核心概念，即所有权和生命周期。这两大概念本质是对语法的一种限制，目的是在混沌中建立足够的秩序，以便让 Rust 在编译期有能力验证程序中是否存在安全问题。所有权系统解决了内存释放以及二次释放的问题，生命周期系统则解决了悬垂指针问题。

当然，在工程领域，一切选择皆是权衡。Rust 不是完美的等边三角，兼顾了安全和性能，则必然要付出一些代价，包括更长的编译时间、更高的心智负担，还有更要命的——你甚至无法用 safe rust 写出一个双向链表，更遑论红黑树这种复杂的数据结构。但这并非不可接受，因为手写这些数据结构的机会并不多，你可以用标准库替你准备好的代替，也可以在 unsafe 中封装这些“不安全”的结构。记住，..unsafe.. 不是 nosafe，只是将安全保证由编译器交到程序员手中，它与 C/C++ 没什么区别，甚至还更安全一点。

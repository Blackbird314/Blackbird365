+++
title = "Rust 核心语法：所有权与借用"
date = "2024-05-21T18:19:51+08:00"
tags = ["Rust"]
description = "但是，古尔丹，代价是什么呢？"
slug = "rust-ownership"
+++

## 引言

所有编程语言都无法回避的一个问题是内存管理，理想中的编程语言应该有以下两个特点：

- 内存对象能在正确的时机及时释放，这使我们能控制程序的内存消耗
- 在内存对象被释放后，不应该继续使用指向它的指针，这会导致崩溃和安全漏洞

由此诞生出两大阵营：1)以 C/C++/Zig 为代表，手动管理内存的申请和释放，但避免内存泄漏和悬空指针是程序员的责任。2)依靠垃圾回收机制(Garbage Collection)自动管理，在所有指向内存对象的指针都消失后，自动释放对应内存。但这会严重影响程序性能，几乎所有现代编程语言，从 Java/Python/Haskell 到 Go/Javascript 都在此列。

为了同时兼顾安全与性能，Rust 选择了第三种方式：由编译器管理内存，即编译时就决定何时释放内存，并将相关指令在恰当位置写入可执行程序。这种方式可以理解为编译期 GC，既不会影响运行时性能，也可以保证内存安全和并发安全（虽然 Rust 无法完全避免内存泄漏，但至少大大降低了它发生的概率，这是后话）。

为了满足要求，Rust 语言提出了两个核心概念，即所有权(Ownership)和生命周期(Lifetimes)。这两大概念本质是对语法的一种限制，目的是在混沌中建立足够的秩序，以便让 Rust 在编译期有能力验证程序是否安全。所有权系统解决了内存释放以及二次释放的问题，生命周期系统则解决了悬垂指针问题。

当然，在工程领域，..一切选择皆是权衡..。Rust 不是完美的等边三角，兼顾了安全和性能，则必然要付出一些代价，包括更长的编译时间、更高的心智负担，还有最要命的——你很难用 safe rust 写出一个双向链表，更遑论红黑树这种复杂结构。但这并非不可接受，因为手写这些数据结构的机会并不多，你可以用标准库代替，也可以在 unsafe 中封装这些“不安全”的结构。记住，..unsafe.. 不是 ..nosafe..，只是将安全保证由编译器交到程序员手中，它与 C/C++ 没什么区别，甚至还更安全和现代一点。

## Rust 内存模型

在程序运行时，操作系统会为程序分配内存空间，并将之加载进内存。分配的内存包括了堆区、栈区、静态数据区、只读数据区和只读指令区，如图所示：

![2024-05-23-17-54-54.png](/images/2024-05-23-17-54-54.png)

对于每个部分存储的内容，大致有如下分类：

1. Stack（栈）
   - 栈用于存储函数参数和局部变量
   - 栈内存分配是连续的，操作系统对栈内存大小有所限制，因此你无法创建过长的数组
   - 栈内存对象的数据类型及其大小必须已知
   - 栈内存的分配效率要高于堆内存
2. Heap（堆）
   - 程序员主动申请使用，一般做大量数据读写时使用，相比栈，堆分配效率较低
3. Static Data（静态数据区）
   - 存放一般的静态函数、静态局部变量和静态全局变量，在程序启动时初始化
4. Literals（只读数据区）
   - 存放代码的文字常量（比如字符串字面量）
5. Instructions（只读代码区）
   - 存放可执行代码

## 所有权规则

Rust 的所有权系统基于以下事实:

1. 编译器能够解析局部变量的生命周期，正确管理栈内存的入栈和出栈
2. 堆内存最终都是通过栈变量（指针和引用）来读取和修改

那么，能否让堆内存管理和栈内存管理一样轻松，成为编译期就生成好的指令呢？根据这个思路，Rust 将堆内存的生命周期和栈变量绑定在一起，当函数栈被回收，局部变量被销毁时，其对应的堆内存（如果有的话）也会被析构函数回收。

考虑一个普通的初始化语句：

```Rust
fn main() {
    let Variable: Type = Value;

    // Variable 离开作用域；
}
```

`Variable` 被称为变量名，`Type` 是其类型，而 `Value` 被称为..内存对象..，也叫做值。每一个赋值操作称为值..绑定..，因为此时不仅仅对变量进行了赋值，我们还把..内存对象的所有权..一并给予了变量。此处的内存对象 `Value` 可以是栈内存，也可以是堆内存（但它一定有一个栈指针），不管哪一种，我们都称变量对内存对象具备所有权。

> 问题辨析：既然堆内存都是由栈上指针进行管理的，那么当 `Value` 是 `String::from("xxx")` 这样的堆内存时，严格来说，`Variable` 拥有的只是栈上的宽指针而非堆上字符串。只是为了方便理解，也经常会说 `Variable` 是那个堆中实际数据的所有者。

Rust 所有权的核心规则很简单：

1. 每一个内存对象，在任意时刻，都有且只有一个称作所有者(owner)的变量
2. 当所有者（变量）离开作用域时，这个内存对象将被释放

编译器知道本地变量 `Variable` 何时离开作用域，自然也就知道何时执行对内存对象 `Value` 的回收。而所有者唯一，保证了不会出现二次释放同一内存的错误。

切记，所有权是一个编译器抽象的概念，它不存在于实际的代码中，仅仅是一种思想和规则。

## 所有权转移

其他语言往往有深拷贝和浅拷贝两个概念，浅拷贝是只拷贝数据对象的引用，深拷贝是根据引用递归到最终的数据并拷贝数据。

在 Rust 中，没有深浅拷贝的概念，但有移动(move)、拷贝(copy)和克隆(clone)的区别。

考虑以下代码：

```Rust
let mut s1 = String::from("big str");
let s2 = s1;

// 下面将报错 error: borrow of moved value: `s1`
println!("{},{}", s1, s2); 

// 重新赋值
s1 = String::from("new str");
```

将 `s1` 赋值给 `s2` 会发生什么？如果将 `s1` 宽指针复制一份给 `s2`，那么按照所有权规则，`s1` `s2` 离开作用域后自动销毁堆中对应数据，会导致内存二次释放，这不仅危险且毫无必要；如果拷贝一份 `s1` 指向的堆内存交给 `s2`，这又违背了 Rust 性能优先的原则。

实际上，这时候 Rust 会进行所有权转移(move)：直接让 `s1` 无效（`s1` 仍然存在，只是变成未初始化的变量，只要 `s1` 是 mutable 的，你还可以重新为其赋值），同时将 `s1` 宽指针复制一份给 `s2`，这样 `s2` 就绑定了堆内存对象，也就是将 `s1` 的所有权移动到 `s2` 手中，如下图所示：

![2024-05-23-20-48-24.png](/images/2024-05-23-20-48-24.png)

注意，因为声明的 `s2` 是不可变变量，你不能通过它修改字符串值：

```Rust
// s1 s2 不可变
let s1 = String::from("big str");

let s2 = s1;
// s2.push('C');  // 报错

let mut s3 = s2;
// s3.push('C');  // 正确
```

### 编译器优化

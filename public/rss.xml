<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Ninephoenix</title><link>https://ninephoenix.dev/</link><description>这是九头鸟的个人网站！</description><generator>Hugo 0.125.7 https://gohugo.io/</generator><language>zh-hans</language><managingEditor>sirius.su128@gmail.com (Ninephoenix)</managingEditor><webMaster>sirius.su128@gmail.com (Ninephoenix)</webMaster><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><lastBuildDate>Wed, 22 May 2024 17:53:10 +0800</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://ninephoenix.dev/rss.xml"/><item><title>Rust 核心语法辨析：所有权与借用</title><link>https://ninephoenix.dev/tech/rust-ownership/</link><guid isPermaLink="true">https://ninephoenix.dev/tech/rust-ownership/</guid><pubDate>Tue, 21 May 2024 18:19:51 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description/><category domain="https://ninephoenix.dev/tech/">tech\</category></item><item><title>tre</title><link>https://ninephoenix.dev/life/try/</link><guid isPermaLink="true">https://ninephoenix.dev/life/try/</guid><pubDate>Mon, 20 May 2024 14:16:39 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description>&lt;p>sdsddssdds&lt;/p></description><category domain="https://ninephoenix.dev/life/">life\</category></item><item><title>Rust 语法辨析：切片和字符串</title><link>https://ninephoenix.dev/tech/rust-slice-str/</link><guid isPermaLink="true">https://ninephoenix.dev/tech/rust-slice-str/</guid><pubDate>Sun, 19 May 2024 12:38:05 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description>&lt;h2 id="何为切片-slice">何为切片 Slice&lt;/h2>
&lt;p>Rust 中，&lt;a href="https://doc.rust-lang.org/reference/types/slice.html">切片(slice)&lt;/a>是一种&lt;a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html">动态尺寸类型(Dynamically sized type)&lt;/a>，切片类型的泛型写法是 &lt;code>[T]&lt;/code>，它是对内存中一系列 &lt;code>T&lt;/code> 类型元素所组成序列的“视图”。这里的内存，可能是堆(Heap)、栈(Stack)、只读数据区(Literals)。特别的，&lt;code>str&lt;/code> 类型本质上就是符合 &lt;code>UTF-8&lt;/code> 编码的 &lt;code>[u8]&lt;/code> 类型，它就是字符串切片。&lt;/p>
&lt;blockquote>
&lt;p>UTF-8(8-bit Unicode Transformation Format/Universal Character Set)是在 Unicode 标准基础上定义的一种可变长度字符编码。它可以表示 Unicode 标准中的任何字符，而且其编码中的第一个字节仍与 ASCII 兼容。&lt;/p>
&lt;/blockquote>
&lt;p>Slice 类型非常特殊，在代码层面，它并不真的存在。换言之，你不能在代码中声明一个 &lt;code>[T]&lt;/code> 类型的变量并拥有 &lt;code>[T]&lt;/code> 内存对象的所有权。以 &lt;code>str&lt;/code> 为例，它只能以 &lt;code>&amp;amp;str&lt;/code> &lt;code>&amp;amp;mut str&lt;/code> &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> &lt;code>String&lt;/code> 等形式呈现，前两者是对 &lt;code>str&lt;/code> 的引用，后两者包含了指向 &lt;code>str&lt;/code> 的指针。&lt;/p>
&lt;p>对于 slice 类型 &lt;code>[T]&lt;/code> 而言，有三种常见的切片引用：&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;amp;[T]&lt;/code>：共享切片(shared slice)，是切片的不可变借用，它不拥有 &lt;code>[T]&lt;/code> 内存对象的所有权。..为了方便，共享切片也被简称为切片..&lt;/li>
&lt;li>&lt;code>&amp;amp;mut [T]&lt;/code>：可变切片(mutable slice)，可变借用于它指向的 &lt;code>[T]&lt;/code> 内存对象，同样没有所有权&lt;/li>
&lt;li>&lt;code>Box&amp;lt;[T]&amp;gt;&lt;/code>：智能指针切片(boxed slice)，&lt;code>[T]&lt;/code> 内存对象存储在堆(heap)上，Box 切片拥有它的所有权&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 一个在堆上分配的数组 [i32; 3] 被自动强转成切片 [i32]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">boxed_array&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Box&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 数组形式的共享切片
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">slice&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">boxed_array&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然 &lt;code>[T]&lt;/code> 和 &lt;code>str&lt;/code> 本身都是可变的（不妨试着用 &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 调用 &lt;code>make_ascii_uppercase()&lt;/code> 验证），但某些情况下是只读/不可变的，这时 Rust 编译器只允许我们使用它的不可变引用 &lt;code>&amp;amp;[T]&lt;/code> &lt;code>&amp;amp;str&lt;/code>。一个常见的例子是字符串字面量，它被硬编码进二进制程序，在程序运行的整个生命周期内都有效，因此绑定它的变量具有静态生命周期，换言之，绑定该字面量的变量类型实际是 &lt;code>&amp;amp;'static str&lt;/code>。（这并不意味着有 &lt;code>'static&lt;/code> 生命周期的 &lt;code>str&lt;/code> 类型就不可变，仍然有办法构造出具有 &lt;code>'static&lt;/code> 生命周期的 &lt;code>&amp;amp;mut str&lt;/code>）&lt;/p>
&lt;p>切片的所有元素总是初始化过的，使用 Rust 中的安全(safe)方法或操作符来访问切片时总是会做越界检查。&lt;/p>
&lt;p>有些编程语言（如 C 语言）会在字符串末尾添加一个零字符 &lt;code>\0&lt;/code>，并记录起始地址。要确定字符串的长度，程序必须从起始位置开始遍历原始字节，直到找到这个零字节。但 Rust 采用的方法不同：它用来访问字符串的 &lt;code>&amp;amp;str&lt;/code> 引用是宽指针，包括了字符串起始地址（裸指针）和所需字节数，这比追加零字节更好，因为计算在编译时就提前完成。&lt;/p>
&lt;p>事实上，上述三种切片引用都是宽指针，均包括了指向内存对象的指针和内存对象的尺寸，是普通指针的两倍大小。你可能会好奇，为什么切片的引用都是宽指针？这和我们之前提到的动态尺寸类型有关。&lt;/p>
&lt;h2 id="动态尺寸类型-dst">动态尺寸类型 DST&lt;/h2>
&lt;p>Rust 中大多数的类型都有一个在编译时就已知的固定尺寸，并实现了 trait &lt;code>Sized&lt;/code>。只有在运行时才知道尺寸的类型称为动态尺寸类型(dynamically sized type)（DST），或者非正式地称为非固定尺寸类型(unsized type)。切片和&lt;a href="https://www.zhihu.com/question/581900340/answer/2873592812">特征对象(trait object)&lt;/a>是 DSTs 的两个例子。&lt;/p>
&lt;p>注意，这里提到的尺寸未知是对类型而言，即 DST(slice, trait object) ..类型的尺寸..无法确定，而非变量值的尺寸。例如，&lt;code>str&lt;/code> 类型可以是任意长度（只要不超出计算机内存的限制），但具体到一个字符串字面量 &lt;code>&amp;quot;Hello World!&amp;quot;&lt;/code>，其长度在编译时是确定无疑且不可更改的。&lt;/p>
&lt;p>固定尺寸类型的引用只需要指向该类型内存对象的第一个字节，不需要知道内存对象的尺寸，因为 Rust 在编译时会生成包含类型信息的机器码，对每个固定尺寸类型的数据，Rust 都能知道其类型，从而确定大小。但对于动态尺寸类型，即使知道内存对象的类型，也无法确定应该引用的内存范围，因而必须使用宽指针。&lt;/p>
&lt;h2 id="string-字符串">&lt;code>String&lt;/code> 字符串&lt;/h2>
&lt;p>如前所述，Rust &lt;code>str&lt;/code> 是符合 &lt;code>UTF-8&lt;/code> 规范的一串 &lt;code>[u8]&lt;/code> 数据，同理 &lt;code>String&lt;/code> 类型是基于 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 的封装，二者堆内存分配策略一致：&lt;code>2-&amp;gt;4-&amp;gt;8&lt;/code>，如果容量不够，下次申请的为前一次的 2 倍。&lt;/p>
&lt;p>&lt;code>String&lt;/code> 类型在标准库中的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，&lt;code>String&lt;/code> 类型定义中的 &lt;code>vec&lt;/code> 字段是私有的。这意味着我们不能直接创建字符串实例，只能通过封装的方法来创建。之所以保持私有，是因为并非所有 &lt;code>[u8]&lt;/code> 字节流都符合 &lt;code>UTF-8&lt;/code> 标准，与底层 &lt;code>u8&lt;/code> 字节的直接交互可能会破坏数据。通过这种受控访问，编译器可以确保 &lt;code>String&lt;/code> 数据始终有效。以下是两种初始化 &lt;code>String&lt;/code> 的方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hello_world&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// hello_world 指向制度数据区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 发生了变量遮蔽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">world&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// world 指向堆
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>String&lt;/code> 类型是一个存储在栈上的宽指针，包括三部分：指针、长度和容量，相比于 &lt;code>&amp;amp;str&lt;/code> 类型仅增加了一个容量字段，因为 &lt;code>String&lt;/code> 指向的的 &lt;code>str&lt;/code> 是堆上数据，所以运行过程中它的长度可以动态改变。&lt;/p>
&lt;p>&lt;img alt="alt text" src="https://ninephoenix.dev/images/str-pointer.png" title="s 是 String 类型，world 是 &amp;amp;str 类型">&lt;/p>
&lt;h2 id="boxstr-字符串">&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 字符串&lt;/h2>
&lt;p>&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 类型是 &lt;code>Box&amp;lt;[T]&amp;gt;&lt;/code> 的子集，如前所述，它是一个智能指针/宽指针，将 &lt;code>str&lt;/code> 放在堆上。不同于 &lt;code>&amp;amp;str&lt;/code> &lt;code>&amp;amp;mut str&lt;/code>，&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 拥有内存对象的所有权。相比 &lt;code>String&lt;/code> 类型，&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 缺少 &lt;code>capacity&lt;/code> 字段，这意味着无法修改 &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 中 &lt;code>str&lt;/code> 的长度，只能改变 &lt;code>str&lt;/code> 中每个字符的值。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;code>[T]&lt;/code> &lt;code>str&lt;/code> 类型数据可以存储在以下三种位置：&lt;/p>
&lt;ul>
&lt;li>只读数据区：绑定的字符串字面量 &lt;code>&amp;quot;hello&amp;quot;&lt;/code> 直接被硬编码进二进制程序中，运行时载入内存的只读数据区&lt;/li>
&lt;li>Heap 堆：&lt;code>Box&amp;lt;T&amp;gt;&lt;/code> &lt;code>String&lt;/code> 类型&lt;/li>
&lt;li>Stack 栈：对于分配到栈上的字节数组，可以将其转换为 &lt;code>&amp;amp;str&lt;/code> 类型的字符串，这时的 &lt;code>str&lt;/code> 存储在栈上：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">str&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;b&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_str&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">str&lt;/span>::&lt;span class="n">from_utf8&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一图以蔽之，Rust 字符串内存模型如下：&lt;/p>
&lt;p>&lt;img alt="alt text" src="https://ninephoenix.dev/images/rust-str-model.webp">&lt;/p></description><category domain="https://ninephoenix.dev/tech/">tech\</category><category domain="https://ninephoenix.dev/tags/rust/">rust</category><category domain="https://ninephoenix.dev/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Ninephoenix</title><link>https://ninephoenix.dev/</link><description>这是九头鸟的个人网站！</description><generator>Hugo 0.125.7 https://gohugo.io/</generator><language>zh-hans</language><managingEditor>sirius.su128@gmail.com (Ninephoenix)</managingEditor><webMaster>sirius.su128@gmail.com (Ninephoenix)</webMaster><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><lastBuildDate>Sat, 25 May 2024 12:17:59 +0800</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://ninephoenix.dev/rss.xml"/><item><title>Rust 核心语法：生命周期与借用检查</title><link>https://ninephoenix.dev/tech/rust-lifetimes/</link><guid isPermaLink="true">https://ninephoenix.dev/tech/rust-lifetimes/</guid><pubDate>Fri, 24 May 2024 17:37:27 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description/><category domain="https://ninephoenix.dev/tech/">tech\</category></item><item><title>Rust 核心语法：所有权与借用</title><link>https://ninephoenix.dev/tech/rust-ownership/</link><guid isPermaLink="true">https://ninephoenix.dev/tech/rust-ownership/</guid><pubDate>Tue, 21 May 2024 18:19:51 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description>&lt;h2 id="引言">引言&lt;/h2>
&lt;p>所有编程语言都无法回避的一个问题是内存管理，理想的编程语言应该有以下两个特点：&lt;/p>
&lt;ul>
&lt;li>内存对象能在正确的时机及时释放，这使我们能控制程序的内存消耗&lt;/li>
&lt;li>在内存对象被释放后，不应该继续使用指向它的指针，这会导致崩溃和安全漏洞&lt;/li>
&lt;/ul>
&lt;p>由此诞生出两大阵营：1)以 C/C++/Zig 为代表，手动管理内存的申请和释放，但避免内存泄漏和悬空指针是程序员的责任。2)依靠垃圾回收机制(Garbage Collection)自动管理，在所有指向内存对象的指针都消失后，自动释放对应内存。但这会严重影响程序性能，几乎所有现代编程语言，从 Java/Python/Haskell 到 Go/Javascript 都在此列。&lt;/p>
&lt;p>为了同时兼顾安全与性能，Rust 选择了第三种方式：由编译器管理内存（编译期 GC），即编译时就决定何时释放内存，并将相关指令在恰当位置写入可执行程序。这种方式不会带来任何运行时开销，也可以保证内存安全和并发安全（虽然 Rust 无法完全避免内存泄漏，但至少大大降低了它发生的概率，这是后话）。&lt;/p>
&lt;p>为了满足要求，Rust 语言提出了两个核心概念，即所有权(Ownership)和生命周期(Lifetimes)。这两大概念本质是对语法的一种限制，目的是在混沌中建立足够的秩序，以便让 Rust 在编译期有能力验证程序是否安全。所有权系统解决了内存释放以及二次释放的问题，生命周期系统则解决了悬垂指针问题。&lt;/p>
&lt;p>当然，在工程领域，..一切选择皆是权衡..。Rust 不是完美的等边三角，兼顾了安全和性能，则必然要付出一些代价，包括更长的编译时间、更高的心智负担，还有最要命的语法限制——你很难用 safe rust 写出一个双向链表，更遑论红黑树这种复杂结构。但这并非不可接受，因为手写这些数据结构的机会并不多，你可以用标准库代替，也可以在 unsafe 中封装这些“不安全”的结构。记住，..unsafe.. 不是 ..nosafe..，只是将安全保证由编译器交到程序员手中，它与 C/C++ 没什么区别，甚至还更安全和现代一点。&lt;/p>
&lt;h2 id="rust-内存模型">Rust 内存模型&lt;/h2>
&lt;p>在程序运行时，操作系统会为程序分配内存空间，并将之加载进内存。分配的内存包括了堆区、栈区、静态数据区、只读数据区和只读指令区，如图所示：&lt;/p>
&lt;p>&lt;img alt="2024-05-23-17-54-54.png" src="https://ninephoenix.dev/images/2024-05-23-17-54-54.png">&lt;/p>
&lt;p>对于每个部分存储的内容，大致有如下分类：&lt;/p>
&lt;ol>
&lt;li>Stack（栈）
&lt;ul>
&lt;li>栈用于存储函数参数和局部变量，内存对象的数据类型及其大小必须已知&lt;/li>
&lt;li>栈内存分配是连续的，操作系统对栈内存大小有所限制，因此你无法创建过长的数组&lt;/li>
&lt;li>栈内存的分配效率要高于堆内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Heap（堆）
&lt;ul>
&lt;li>程序员主动申请使用，一般做大量数据读写时使用，相比栈，堆分配效率较低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Static Data（静态数据区）
&lt;ul>
&lt;li>存放一般的静态函数、静态局部变量和静态全局变量，在程序启动时初始化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Literals（只读数据区）
&lt;ul>
&lt;li>存放代码的文字常量，比如字符串字面量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Instructions（只读代码区）
&lt;ul>
&lt;li>存放可执行代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="所有权规则">所有权规则&lt;/h2>
&lt;p>Rust 的所有权系统基于以下事实:&lt;/p>
&lt;ol>
&lt;li>编译器能够解析局部变量的生命周期，正确管理栈内存的入栈和出栈&lt;/li>
&lt;li>堆内存最终都是通过栈变量（指针和引用）来读取和修改&lt;/li>
&lt;/ol>
&lt;p>那么，能否让堆内存管理和栈内存管理一样轻松，成为编译期就生成好的指令呢？根据这个思路，Rust 将堆内存的生命周期和栈变量绑定在一起，当函数栈被回收，局部变量被销毁时，其对应的堆内存（如果有的话）也会被析构函数 &lt;code>drop()&lt;/code> 回收。&lt;/p>
&lt;blockquote>
&lt;p>在 C++ 中，这种 item 在生命周期结束时释放资源的模式被称作..资源获取即初始化.. Resource Acquisition Is Initialization (RAII)&lt;/p>
&lt;/blockquote>
&lt;p>考虑一个普通的初始化语句：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Variable&lt;/span>: &lt;span class="nc">Type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Variable 离开作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Variable&lt;/code> 被称为变量，&lt;code>Type&lt;/code> 是其类型，而 &lt;code>Value&lt;/code> 被称为..内存对象..，也叫做值。每一个赋值操作称为值..绑定..，因为此时不仅仅对变量进行了赋值，我们还把..内存对象的所有权..一并给予了变量。此处的内存对象 &lt;code>Value&lt;/code> 可以是栈内存，也可以是堆内存（但它一定有一个栈指针）。&lt;/p>
&lt;blockquote>
&lt;p>重点辨析：既然堆内存都是由栈上指针进行管理的，那么当 &lt;code>Value&lt;/code> 是 &lt;code>String::from(&amp;quot;xxx&amp;quot;)&lt;/code> 这样的堆内存时，严格来说，&lt;code>Variable&lt;/code> ..拥有的是栈上指针的所有权..，而非堆上字符串(&lt;code>Value&lt;/code>)的所有权。只是为了方便理解，也经常会说 &lt;code>Variable&lt;/code> 是那个堆中实际数据的所有者。&lt;/p>
&lt;/blockquote>
&lt;p>Rust 所有权的核心规则很简单：&lt;/p>
&lt;ol>
&lt;li>每一个内存对象，在任意时刻，都有且只有一个称作所有者(owner)的变量&lt;/li>
&lt;li>当所有者（变量）离开作用域时，这个内存对象将被释放&lt;/li>
&lt;/ol>
&lt;p>编译器知道本地变量 &lt;code>Variable&lt;/code> 何时离开作用域，自然也就知道何时执行对内存对象 &lt;code>Value&lt;/code> 的回收。而所有者唯一，保证了不会出现二次释放同一内存的错误。&lt;/p>
&lt;p>切记，所有权是一个编译器抽象的概念，它不存在于实际的代码中，仅仅是一种思想和规则。&lt;/p>
&lt;h2 id="所有权转移">所有权转移&lt;/h2>
&lt;p>其他语言往往有深拷贝和浅拷贝两个概念，浅拷贝是只拷贝数据对象的引用，深拷贝是根据引用递归到最终的数据并拷贝数据。&lt;/p>
&lt;p>Rust 为了适应所有权系统，没有使用深浅拷贝的概念，而是提出了移动(Move)、拷贝(Copy)和克隆(Clone)的区别。&lt;/p>
&lt;h3 id="move-语义">Move 语义&lt;/h3>
&lt;p>考虑以下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;big str&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 下面将报错 error: borrow of moved value: `s1`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">,&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 重新赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// &amp;#34;big str&amp;#34; 被自动释放，为 &amp;#34;new str&amp;#34; 分配新的堆内存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;new str&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 &lt;code>s1&lt;/code> 赋值给 &lt;code>s2&lt;/code> 会发生什么？如果将 &lt;code>s1&lt;/code> 宽指针复制一份给 &lt;code>s2&lt;/code>，那么按照所有权规则，&lt;code>s1&lt;/code> &lt;code>s2&lt;/code> 离开作用域后自动销毁堆中对应数据，会导致内存二次释放，这不仅危险且毫无必要；如果拷贝一份 &lt;code>s1&lt;/code> 指向的堆内存交给 &lt;code>s2&lt;/code>，这又违背了 Rust 性能优先的原则。&lt;/p>
&lt;p>实际上，这时候 Rust 会进行所有权转移(Move)：直接让 &lt;code>s1&lt;/code> 无效（&lt;code>s1&lt;/code> 仍然存在，..只是变成未初始化的变量..，只要 &lt;code>s1&lt;/code> 是可变的，你还可以重新为其初始化），同时将 &lt;code>s1&lt;/code> 栈内存对象复制一份给 &lt;code>s2&lt;/code>，这样 &lt;code>s2&lt;/code> 就指向了同一个堆内存对象，也就是将 &lt;code>s1&lt;/code> 的所有权移动到 &lt;code>s2&lt;/code> 手中，如图所示：&lt;/p>
&lt;p>&lt;img alt="2024-05-23-20-48-24.png" src="https://ninephoenix.dev/images/2024-05-23-20-48-24.png">&lt;/p>
&lt;p>因为声明的 &lt;code>s2&lt;/code> 是不可变变量，你不能通过它修改字符串值，但编译期的 &lt;code>mut&lt;/code> 标识是作用在变量名上，而不是那个内存对象。因此下面的例子中 &lt;code>s1&lt;/code> 不可变，并不妨碍我们定义另外一个可变的变量名 &lt;code>s3&lt;/code> 来写这块内存：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// s1 s2 不可变 s3 可变
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;big str&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// s2.push(&amp;#39;C&amp;#39;); // 报错
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">s3&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;C&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 正确
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="编译期检查">编译期检查&lt;/h4>
&lt;p>所有权检查是编译期的静态检查，编译器通常不会考虑你的程序将怎样运行，而是基于代码结构做出判断，这使得它经常看上去不那么聪明。&lt;/p>
&lt;p>比如依次写两个条件互斥的 &lt;code>if&lt;/code>，编译器不会考虑那么多，直接告诉你不能移动 &lt;code>x&lt;/code> 两次：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">foobar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>: &lt;span class="kt">isize&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// error[E0382]: use of moved value: `x`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>甚至把 &lt;code>Move&lt;/code> 操作放在循环次数固定为 1 的 &lt;code>for&lt;/code> 循环内，编译器也傻傻看不出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">foobar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// error[E0382]: use of moved value: `x`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="编译器优化">编译器优化&lt;/h4>
&lt;p>&lt;code>Move&lt;/code> 语义不仅出现在变量赋值过程中，在函数传参、函数返回数据时也会发生，因此，如果将一个大对象（例如过长的数组，包含很多字段的 &lt;code>struct&lt;/code>）作为参数传递给函数，可能会影响程序性能。&lt;/p>
&lt;p>因此 Rust 编译器会对 &lt;code>Move&lt;/code> 语义的行为做出一些优化，简单来说，当数据量较大且不会引起程序正确性问题时，它会优化为传递大对象的指针而非内存拷贝。&lt;sup id="fnref:1">&lt;a href="https://ninephoenix.dev/tech/rust-ownership/#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>总之，&lt;code>Move&lt;/code> 语义虽然发生了栈内存拷贝，但性能并不会受太大影响。&lt;/p>
&lt;h3 id="copy-语义">Copy 语义&lt;/h3>
&lt;p>你可能会想，如果每次赋值都要令原变量失效，是否太麻烦了？为此，Rust 提出了 &lt;code>Copy&lt;/code> 语义，和 Move 语义的唯一区别是，&lt;code>Copy&lt;/code> 后..原变量仍然可用..。换言之，&lt;code>Copy&lt;/code> 等同于“浅拷贝”，会对栈内存做按位复制，而不对任何堆内存负责，原变量和新变量各自绑定独立的栈内存，..并拥有其所有权..。显然，如果变量指向了堆内存对象，&lt;code>Copy&lt;/code> 语义会导致二次释放的错误，因此 Rust 默认使用 &lt;code>Move&lt;/code> 语义，只有实现了 &lt;code>Copy&lt;/code> Trait 的类型在所有权转移时 &lt;code>Copy&lt;/code>。&lt;/p>
&lt;p>例如，标准库的 &lt;code>i32&lt;/code> 类型就默认已经实现了 &lt;code>Copy&lt;/code> Trait，因此它在进行所有权转移的时候，会自动使用 &lt;code>Copy&lt;/code> 而非 &lt;code>Move&lt;/code> 语义，赋值后原变量仍可用。&lt;/p>
&lt;p>Rust 默认实现 &lt;code>Copy&lt;/code> Trait 的类型，包括但不限于：&lt;/p>
&lt;ul>
&lt;li>所有整数类型&lt;/li>
&lt;li>所有浮点数类型&lt;/li>
&lt;li>布尔类型&lt;/li>
&lt;li>字符类型&lt;/li>
&lt;li>元组，当且仅当其包含的类型也都实现 &lt;code>Copy&lt;/code> 的时候。比如 &lt;code>(i32, i32)&lt;/code> 是 &lt;code>Copy&lt;/code> 的，但 &lt;code>(i32, String)&lt;/code> 不是&lt;/li>
&lt;li>共享指针类型 &lt;code>*const T&lt;/code> 或共享引用类型 &lt;code>&amp;amp;T&lt;/code>（无论 T 是否实现 &lt;code>Copy&lt;/code>）&lt;/li>
&lt;/ul>
&lt;p>对于那些没有实现 &lt;code>Copy&lt;/code> Trait 的自定义类型，可以通过 &lt;code>#[derive]&lt;/code> 手动派生实现(要求同时实现 &lt;code>Clone&lt;/code> Trait)，方式很简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#[derive(Copy, Clone)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyStruct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你也可以手动实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyStruct&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Copy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyStruct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Clone&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyStruct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">MyStruct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，只有当某类型的所有成员都实现了 &lt;code>Copy&lt;/code>，该类型才能够实现 &lt;code>Copy&lt;/code>。“成员(Member)”的含义取决于类型，例如：结构体的字段、枚举的变量、数组的元素、元组的项，等等。&lt;/p>
&lt;p>Rust 标准库文档提到&lt;sup id="fnref:2">&lt;a href="https://ninephoenix.dev/tech/rust-ownership/#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，一般来说，如果你的类型可以实现 &lt;code>Copy&lt;/code>，它就应该实现。但实现 &lt;code>Copy&lt;/code> 是你的类型公共 API 的一部分。如果该类型可能在未来变成非 &lt;code>Copy&lt;/code>，那么现在省略 &lt;code>Copy&lt;/code> 的实现可能会是明智的选择，以避免 API 的破坏性改变。&lt;/p>
&lt;p>那么哪些类型不能实现 &lt;code>Copy&lt;/code> 呢？任何自身或部分实现了 &lt;code>Drop&lt;/code> Trait 的类型都不可实现 &lt;code>Copy&lt;/code>，比如 &lt;code>String&lt;/code> 和 &lt;code>Vec&amp;lt;T&amp;gt;&lt;/code> 类型，可以说 &lt;code>Copy&lt;/code> 与 &lt;code>Drop&lt;/code> 是两个互斥的 Trait。&lt;/p>
&lt;p>&lt;code>Drop&lt;/code> Trait 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Drop&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// Required method
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当一个值不再被需要时（比如离开作用域），Rust 会运行 &amp;quot;destructor&amp;quot; 将其释放。如果该类型实现了 &lt;code>Drop&lt;/code> Trait，destructor 会调用 &lt;code>Drop::drop&lt;/code> 析构函数，但即使没有实现这个 &lt;code>Drop&lt;/code>，destructor 也会自动生成 &amp;quot;drop glue&amp;quot;，递归地为这个值的所有成员调用析构函数。因此在大多数情况下，你不必为你的类型实现 &lt;code>Drop&lt;/code>。&lt;/p>
&lt;p>除此之外，&lt;code>Copy&lt;/code> 一个可变引用 &lt;code>&amp;amp;mut T&lt;/code> 也是不安全的，这违背了引用的借用规则。&lt;/p>
&lt;h3 id="clone-语义">Clone 语义&lt;/h3>
&lt;p>看见上面的 &lt;code>Clone&lt;/code> Trait 了吗？它也是一个常见的 Trait，实现了 &lt;code>Clone&lt;/code> 的类型变量可以调用 &lt;code>clone()&lt;/code> 方法手动拷贝内存对象，它对复本的整体有效性负责，所以【栈】与【堆】都是 &lt;code>clone()&lt;/code> 的复制目标，这相当于“深拷贝”。&lt;code>Clone&lt;/code> 还是 &lt;code>Copy&lt;/code> 的 Supertrait，看看 &lt;code>Copy&lt;/code> Trait 的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Copy&lt;/span>: &lt;span class="nb">Clone&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这表明，实现 &lt;code>Copy&lt;/code> 的类型必须先实现 &lt;code>Clone&lt;/code>。这是因为实现了 &lt;code>Copy&lt;/code> 的类型在赋值时，会自动调用其 &lt;code>clone()&lt;/code> 方法。如果一个类型是 &lt;code>Copy&lt;/code> 的，那么它的 &lt;code>clone()&lt;/code> 实现只需要返回 &lt;code>*self&lt;/code>（参见上例）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;big str&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 克隆 s1 之后，变量 s1 仍然绑定原始数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">,&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Copy&lt;/code> 的细节被封装在编译器内，无法自行定制和实现，不可重载；而 &lt;code>Clone&lt;/code> 可由开发者自行实现。所以调用 &lt;code>Clone&lt;/code> 的默认实现时，操作的性能是较低的。但你可以实现自己的克隆逻辑，也不一定总是会效率低。比如 &lt;code>Rc&lt;/code>，它的 &lt;code>clone()&lt;/code> 用于增加引用计数，同时只拷贝少量数据，效率并不低。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>总结一下，&lt;code>Move&lt;/code> 语义等于“浅拷贝” + 原变量失效，复制栈内存并移动所有权；&lt;code>Copy&lt;/code> 语义只进行“浅拷贝”，复制栈内存和所有权；&lt;code>Clone&lt;/code> 语义必须显式调用，进行“深拷贝”，复制栈内存、堆内存和所有权。&lt;/p>
&lt;p>另外，在 1)赋值 2)参数传入 3)返回值传出时 &lt;code>Move&lt;/code> 和 &lt;code>Copy&lt;/code> 行为被隐式触发，而 &lt;code>Clone&lt;/code> 行为必须显示调用 &lt;code>Clone::clone(&amp;amp;self)&lt;/code> 成员方法。&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>和 C/C++ 一样，Rust 有裸指针(Pointer)类型和引用(Reference)类型，分别是共享引用（不可变引用） &lt;code>&amp;amp;T&lt;/code> 和可变引用 &lt;code>&amp;amp;mut T&lt;/code>，常量裸指针（不可变指针） &lt;code>*const T&lt;/code> 和 可变裸指针 &lt;code>*T&lt;/code>，他们的值都是 &lt;code>T&lt;/code> 类型对象的地址，都可以通过解引用操作指向内存对象。&lt;/p>
&lt;p>区别在于，Rust 认为裸指针是不安全的操作，所以它只能在 &lt;code>unsafe&lt;/code> 块中使用，引用则是被编译器加了限制的裸指针，遵循借用规则(Borrowing Rules)并由编译器检查，以保证安全。&lt;/p>
&lt;p>为了使用方便，Rust 编译器对引用的作用域进行了优化：普通变量的作用域从创建持续到某一个花括号 &lt;code>}&lt;/code>；引用的作用域从创建开始，一直持续到它最后一次使用的地方。这种优化行为被称为非词法作用域生命周期(Non-Lexical Lifetimes, NLL)&lt;/p>
&lt;p>创建一个引用的行为称为借用(Borrowing)，即引用类型会借用（而非获得）内存对象的所有权。当你只想使用变量，而不想转移所有权时，可以通过变量的引用进行访问，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s1 本质是一个指向堆内存的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">calculate_length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The length of &amp;#39;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#39; is &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">calculate_length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">usize&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s 是指向 s1 的引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>传入 &lt;code>calculate_length()&lt;/code> 的是 &lt;code>s1&lt;/code> 的引用，参数 &lt;code>s&lt;/code> 不会获得 &lt;code>s1&lt;/code> 的所有权，如图所示：&lt;/p>
&lt;p>&lt;img alt="2024-05-24-15-42-23.png" src="https://ninephoenix.dev/images/2024-05-24-15-42-23.png">&lt;/p>
&lt;p>Rust 的借用规则很有趣：在同一时刻，要么只有一个可变引用(&lt;code>&amp;amp;mut T&lt;/code>)，要么有任意数量的共享引用(&lt;code>&amp;amp;T&lt;/code>)。可变引用与共享引用不能同时存在，也不能同时存在多个可变引用。正因如此，可变引用 &lt;code>&amp;amp;mut T&lt;/code> 不能实现 &lt;code>Copy&lt;/code>，这会违反借用规则。当然，共享引用是可 &lt;code>Copy&lt;/code> 的，即把共享引用赋值给另一个共享引用后，可以继续使用。&lt;/p>
&lt;p>为什么会有这样的规定呢？因为 Rust 要求..在同一时刻，一份资源只能被至多一个变量名读写，或者被多个变量名读取..。由此：&lt;/p>
&lt;ul>
&lt;li>对于不可变借用(&lt;code>let y = &amp;amp;x&lt;/code>)：1)引用 &lt;code>y&lt;/code> 是只读的；2)在 &lt;code>y&lt;/code> 作用域结束之前，&lt;code>x&lt;/code> 可读不可写（因为存在 &lt;code>y&lt;/code> 可读），因此 &lt;code>x&lt;/code> 能被不可变借用但不能被可变借用&lt;/li>
&lt;li>对于可变借用(&lt;code>let y = &amp;amp;mut x&lt;/code>)：1)引用 &lt;code>y&lt;/code> 可读写；2)在 &lt;code>y&lt;/code> 作用域结束之前，&lt;code>x&lt;/code> 不可读不可写（因为存在 &lt;code>y&lt;/code> 可写），因此 &lt;code>x&lt;/code> 不能再次被借用&lt;/li>
&lt;/ul>
&lt;p>下面这段代码会报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// y 可变借用于 x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 报错：存在 x 的可变引用 y，此时不能通过原变量 x 读取值（也不可写）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// y 的作用域到此结束
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// x 可以正常读取
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，Rust 中所有的值都有所有权，引用类型的值也不例外。引用不拥有指向对象的所有权，但引用变量拥有自身地址值的所有权。参考下面这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;value&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// r 是 s 的可变引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// move 而非 copy
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 报错 borrow of moved value: `r`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="解引用">解引用&lt;/h2>
&lt;p>解引用操作 &lt;code>*r&lt;/code> 会得到一个被称为影子变量的东西，可以理解为没有所有权的变量别名。它可以用来对本体变量的内存对象进行读写操作，但无法通过影子变量进行所有权转移 &lt;code>Move&lt;/code>（但可以 &lt;code>Copy&lt;/code> 或 &lt;code>Clone&lt;/code>），这会影响本体对于内存对象的掌控：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyType&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">val&lt;/span>: &lt;span class="nc">T&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num1_ref&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">num1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// i32 类型实现了 Copy，因此 i32 类型的影子变量会进行 Copy 操作，这不会影响本体的所有权
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">num1_ref&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyType&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">val&lt;/span>: &lt;span class="mi">1&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 这里报错，因为无法通过解引用得到的影子变量移动所有权
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这张图展示了变量、类型、内存对象、值，引用、解引用和裸指针的概念：&lt;/p>
&lt;p>&lt;img alt="2024-05-24-17-17-25.png" src="https://ninephoenix.dev/images/2024-05-24-17-17-25.png">&lt;/p>
&lt;hr>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>参考：&lt;a href="https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust">https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust&lt;/a>&amp;#160;&lt;a href="https://ninephoenix.dev/tech/rust-ownership/#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>参考：&lt;a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-should-my-type-be-copy">https://doc.rust-lang.org/std/marker/trait.Copy.html#when-should-my-type-be-copy&lt;/a>&amp;#160;&lt;a href="https://ninephoenix.dev/tech/rust-ownership/#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description><category domain="https://ninephoenix.dev/tech/">tech\</category><category domain="https://ninephoenix.dev/tags/rust/">rust</category></item><item><title>测试</title><link>https://ninephoenix.dev/life/try/</link><guid isPermaLink="true">https://ninephoenix.dev/life/try/</guid><pubDate>Mon, 20 May 2024 14:16:39 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description>&lt;p>这是测试用例&lt;/p></description><category domain="https://ninephoenix.dev/life/">life\</category></item><item><title>Rust 语法辨析：切片和字符串</title><link>https://ninephoenix.dev/tech/rust-slice-str/</link><guid isPermaLink="true">https://ninephoenix.dev/tech/rust-slice-str/</guid><pubDate>Sun, 19 May 2024 12:38:05 +0800</pubDate><author>sirius.su128@gmail.com (Ninephoenix)</author><copyright>在保留本文作者及本文连结的前提下，非商业用途随意转载分享。</copyright><description>&lt;h2 id="何为切片-slice">何为切片 Slice&lt;/h2>
&lt;p>Rust 中，&lt;a href="https://doc.rust-lang.org/reference/types/slice.html">切片(slice)&lt;/a>是一种&lt;a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html">动态尺寸类型(Dynamically sized type)&lt;/a>，切片类型的泛型写法是 &lt;code>[T]&lt;/code>，它是对内存中一系列 &lt;code>T&lt;/code> 类型元素所组成序列的“视图”。这里的内存，可能是堆(Heap)、栈(Stack)、只读数据区(Literals)。特别的，&lt;code>str&lt;/code> 类型本质上就是符合 &lt;code>UTF-8&lt;/code> 编码的 &lt;code>[u8]&lt;/code> 类型，它就是字符串切片。&lt;/p>
&lt;blockquote>
&lt;p>UTF-8(8-bit Unicode Transformation Format/Universal Character Set)是在 Unicode 标准基础上定义的一种可变长度字符编码。它可以表示 Unicode 标准中的任何字符，而且其编码中的第一个字节仍与 ASCII 兼容。&lt;/p>
&lt;/blockquote>
&lt;p>Slice 类型非常特殊，在代码层面，它并不真的存在。换言之，你不能在代码中声明一个 &lt;code>[T]&lt;/code> 类型的变量并拥有 &lt;code>[T]&lt;/code> 内存对象的所有权。以 &lt;code>str&lt;/code> 为例，它只能以 &lt;code>&amp;amp;str&lt;/code> &lt;code>&amp;amp;mut str&lt;/code> &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> &lt;code>String&lt;/code> 等形式呈现，前两者是对 &lt;code>str&lt;/code> 的引用，后两者包含了指向 &lt;code>str&lt;/code> 的指针。&lt;/p>
&lt;p>对于 slice 类型 &lt;code>[T]&lt;/code> 而言，有三种常见的切片引用：&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;amp;[T]&lt;/code>：共享切片(shared slice)，是切片的不可变借用，它不拥有 &lt;code>[T]&lt;/code> 内存对象的所有权。..为了方便，共享切片也被简称为切片..&lt;/li>
&lt;li>&lt;code>&amp;amp;mut [T]&lt;/code>：可变切片(mutable slice)，可变借用于它指向的 &lt;code>[T]&lt;/code> 内存对象，同样没有所有权&lt;/li>
&lt;li>&lt;code>Box&amp;lt;[T]&amp;gt;&lt;/code>：智能指针切片(boxed slice)，&lt;code>[T]&lt;/code> 内存对象存储在堆(heap)上，Box 切片拥有它的所有权&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 一个在堆上分配的数组 [i32; 3] 被自动强转成切片 [i32]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">boxed_array&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Box&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 数组形式的共享切片
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">slice&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">boxed_array&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然 &lt;code>[T]&lt;/code> 和 &lt;code>str&lt;/code> 本身都是可变的（不妨试着用 &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 调用 &lt;code>make_ascii_uppercase()&lt;/code> 验证），但某些情况下是只读/不可变的，这时 Rust 编译器只允许我们使用它的不可变引用 &lt;code>&amp;amp;[T]&lt;/code> &lt;code>&amp;amp;str&lt;/code>。一个常见的例子是字符串字面量，它被硬编码进可执行程序，在程序运行的整个生命周期内都有效，因此绑定它的变量具有静态生命周期，换言之，绑定该字面量的变量类型实际是 &lt;code>&amp;amp;'static str&lt;/code>。（这并不意味着有 &lt;code>'static&lt;/code> 生命周期的 &lt;code>str&lt;/code> 类型就不可变，仍然有办法构造出具有 &lt;code>'static&lt;/code> 生命周期的 &lt;code>&amp;amp;mut str&lt;/code>）&lt;/p>
&lt;p>切片的所有元素总是初始化过的，使用 Rust 中的安全(safe)方法或操作符来访问切片时总是会做越界检查。&lt;/p>
&lt;p>有些编程语言（如 C 语言）会在字符串末尾添加一个零字符 &lt;code>\0&lt;/code>，并记录起始地址。要确定字符串的长度，程序必须从起始位置开始遍历原始字节，直到找到这个零字节。但 Rust 采用的方法不同：它用来访问字符串的 &lt;code>&amp;amp;str&lt;/code> 引用是宽指针，包括了字符串起始地址（裸指针）和所需字节数，这比追加零字节更好，因为计算在编译时就提前完成。&lt;/p>
&lt;p>事实上，上述三种切片引用都是宽指针，均包括了指向内存对象的指针和内存对象的尺寸，是普通指针的两倍大小。你可能会好奇，为什么切片的引用都是宽指针？这和我们之前提到的动态尺寸类型有关。&lt;/p>
&lt;h2 id="动态尺寸类型-dst">动态尺寸类型 DST&lt;/h2>
&lt;p>Rust 中大多数的类型都有一个在编译时就已知的固定尺寸，并实现了 Trait &lt;code>Sized&lt;/code>。只有在运行时才知道尺寸的类型称为动态尺寸类型(dynamically sized type)（DST），或者非正式地称为非固定尺寸类型(unsized type)。切片和&lt;a href="https://www.zhihu.com/question/581900340/answer/2873592812">特征对象(Trait object)&lt;/a>是 DSTs 的两个例子。&lt;/p>
&lt;p>注意，这里提到的尺寸未知是对类型而言，即 DST(slice, Trait object) ..类型的尺寸..无法确定，而非变量值的尺寸。例如，&lt;code>str&lt;/code> 类型可以是任意长度（只要不超出计算机内存的限制），但具体到一个字符串字面量 &lt;code>&amp;quot;Hello World!&amp;quot;&lt;/code>，其长度在编译时是确定无疑且不可更改的。&lt;/p>
&lt;p>固定尺寸类型的引用只需要指向内存对象的第一个字节，不需要知道内存对象的尺寸，因为 Rust 在编译时会生成包含类型信息的机器码，对每个固定尺寸类型的数据，Rust 都能知道其类型，从而确定大小。但对于动态尺寸类型，即使知道内存对象的类型(比如明确是 &lt;code>str&lt;/code> 类型)，由于没有自己的大小信息，也无法确定应该引用的内存范围，因而必须使用宽指针。&lt;/p>
&lt;h2 id="string-字符串">&lt;code>String&lt;/code> 字符串&lt;/h2>
&lt;p>如前所述，Rust &lt;code>str&lt;/code> 是符合 &lt;code>UTF-8&lt;/code> 规范的一串 &lt;code>[u8]&lt;/code> 数据，同理 &lt;code>String&lt;/code> 类型是基于 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 的封装，二者堆内存分配策略一致：&lt;code>2-&amp;gt;4-&amp;gt;8&lt;/code>，如果容量不够，下次申请的为前一次的 2 倍。和 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 一样，&lt;code>String&lt;/code> 类型变量的内存对象存储在堆上，且拥有它的所有权。&lt;/p>
&lt;p>&lt;code>String&lt;/code> 类型在标准库中的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，&lt;code>String&lt;/code> 类型定义中的 &lt;code>vec&lt;/code> 字段是私有的。这意味着我们不能直接创建字符串实例，只能通过封装的方法来创建。之所以保持私有，是因为并非所有 &lt;code>[u8]&lt;/code> 字节流都符合 &lt;code>UTF-8&lt;/code> 标准，与底层 &lt;code>u8&lt;/code> 字节的直接交互可能会破坏字符串数据。通过这种受控访问，编译器可以确保 &lt;code>String&lt;/code> 数据始终有效。以下是两种初始化 &lt;code>String&lt;/code> 的方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hello_world&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// hello_world 指向只读数据区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 发生了变量遮蔽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">world&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// world 指向堆
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>显然，&lt;code>&amp;amp;str&lt;/code> 类型可以指向堆，也可以指向只读数据区，还可以指向栈：只需将分配到栈上的字节数组转换为 &lt;code>&amp;amp;str&lt;/code> 类型，这时 &lt;code>str&lt;/code> 自然是栈上的内存对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">str&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;b&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="sc">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_str&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">str&lt;/span>::&lt;span class="n">from_utf8&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作为存储在栈上的宽指针，&lt;code>String&lt;/code> 类型包括三部分：指针、长度和容量，相比于 &lt;code>&amp;amp;str&lt;/code> 类型仅增加了一个容量字段，因为 &lt;code>String&lt;/code> 指向堆内存，所以运行过程中它的长度可以动态改变。&lt;/p>
&lt;p>&lt;img alt="alt text" src="https://ninephoenix.dev/images/str-pointer.png" title="s 是 String 类型，world 是 &amp;amp;str 类型">&lt;/p>
&lt;p>&lt;code>&amp;amp;String&lt;/code> 类型还可以被隐式的转换为 &lt;code>&amp;amp;str&lt;/code> 类型，因此当函数参数为 &lt;code>&amp;amp;str&lt;/code> 类型时，不仅能传入 &lt;code>&amp;amp;str&lt;/code> 变量，也可以传入 &lt;code>&amp;amp;String&lt;/code> 变量，这样的函数使用更加灵活。&lt;/p>
&lt;h2 id="boxstr-字符串">&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 字符串&lt;/h2>
&lt;p>&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 类型是 &lt;code>Box&amp;lt;[T]&amp;gt;&lt;/code> 的子集，如前所述，它是一个智能指针/宽指针，将 &lt;code>str&lt;/code> 放在堆上。不同于 &lt;code>&amp;amp;str&lt;/code> &lt;code>&amp;amp;mut str&lt;/code>，&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 拥有内存对象的所有权。相比 &lt;code>String&lt;/code> 类型，&lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 缺少 &lt;code>capacity&lt;/code> 字段，这意味着无法修改 &lt;code>Box&amp;lt;str&amp;gt;&lt;/code> 中 &lt;code>str&lt;/code> 的长度，只能改变 &lt;code>str&lt;/code> 中每个字符的值。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;code>[T]&lt;/code> &lt;code>str&lt;/code> 类型数据可以存储在以下三种位置：&lt;/p>
&lt;ul>
&lt;li>Heap 堆：&lt;code>Box&amp;lt;T&amp;gt;&lt;/code> &lt;code>String&lt;/code> 类型&lt;/li>
&lt;li>Stack 栈：如前所述&lt;/li>
&lt;li>只读数据区：绑定的字符串字面量 &lt;code>&amp;quot;hello&amp;quot;&lt;/code> 直接被硬编码进可执行程序中，运行时载入内存的只读数据区&lt;/li>
&lt;/ul>
&lt;p>一图以蔽之，Rust 字符串内存模型如下：&lt;/p>
&lt;p>&lt;img alt="alt text" src="https://ninephoenix.dev/images/rust-str-model.webp">&lt;/p></description><category domain="https://ninephoenix.dev/tech/">tech\</category><category domain="https://ninephoenix.dev/tags/rust/">rust</category><category domain="https://ninephoenix.dev/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</category></item></channel></rss>
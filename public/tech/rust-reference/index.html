<!doctype html><html lang=zh-hans><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=UTF-8><meta name=generator content="Hugo 0.127.0"><meta name=theme-color content="#fff"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><title>Rust 核心语法：借用 | Ninephoenix</title>
<link rel=stylesheet href=/css/meme.min.css><script src=/js/meme.min.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400i,500,700,700i%7cBungee+Shade%7cTrade+Winds%7cCinzel+Decorative:700%7cNoto+Serif+SC:400,700%7cSource+Code+Pro:400,400i,700,700i&amp;display=swap&amp;subset=chinese-simplified" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400i,500,700,700i%7cBungee+Shade%7cTrade+Winds%7cCinzel+Decorative:700%7cNoto+Serif+SC:400,700%7cSource+Code+Pro:400,400i,700,700i&amp;display=swap&amp;subset=chinese-simplified"></noscript><meta name=author content="Ninephoenix"><meta name=description content="引用 和 C/C++ 一样，Rust 有裸指针(Pointer)类型和引用(Reference)类型……"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#fff><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Ninephoenix"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Ninephoenix"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://ninephoenix.dev/tech/rust-reference/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2024-07-07T16:39:09+08:00","dateModified":"2024-07-07T16:44:56+08:00","url":"https://ninephoenix.dev/tech/rust-reference/","headline":"Rust 核心语法：借用","description":"引用 和 C/C++ 一样，Rust 有裸指针(Pointer)类型和引用(Reference)类型……","inLanguage":"zh-hans","articleSection":"tech","wordCount":3223,"image":"https://ninephoenix.dev/static/icons/apple-touch-icon.png","author":{"@type":"Person","description":"Done is better than perfect.","email":"sirius.su128@gmail.com","image":"https://ninephoenix.dev/static/icons/apple-touch-icon.png","url":"https://ninephoenix.dev/","name":"Ninephoenix"},"license":"在保留本文作者及本文连结的前提下，非商业用途随意转载分享。","publisher":{"@type":"Organization","name":"Ninephoenix","logo":{"@type":"ImageObject","url":"https://ninephoenix.dev/static/icons/apple-touch-icon.png"},"url":"https://ninephoenix.dev/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://ninephoenix.dev/"}}</script><meta name=twitter:card content="summary"><meta name=twitter:site content="@Ninephoenix9"><meta name=twitter:creator content="@Ninephoenix9"><meta property="og:title" content="Rust 核心语法：借用"><meta property="og:description" content="引用 和 C/C++ 一样，Rust 有裸指针(Pointer)类型和引用(Reference)类型……"><meta property="og:url" content="https://ninephoenix.dev/tech/rust-reference/"><meta property="og:site_name" content="Ninephoenix"><meta property="og:locale" content="zh-hans"><meta property="og:image" content="https://ninephoenix.dev/static/icons/apple-touch-icon.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2024-07-07T16:39:09+08:00"><meta property="article:modified_time" content="2024-07-07T16:44:56+08:00"><meta property="article:section" content="tech"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&amp;text=reuixiy&amp;display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&amp;text=reuixiy&amp;display=swap"></noscript></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Ninephoenix</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/life/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon life"><path d="M301.1 212c4.4 4.4 4.4 11.9.0 16.3l-9.7 9.7c-4.4 4.7-11.9 4.7-16.6.0l-10.5-10.5c-4.4-4.7-4.4-11.9.0-16.6l9.7-9.7c4.4-4.4 11.9-4.4 16.6.0l10.5 10.8zm-30.2-19.7c3-3 3-7.8.0-10.5-2.8-3-7.5-3-10.5.0-2.8 2.8-2.8 7.5.0 10.5 3.1 2.8 7.8 2.8 10.5.0zm-26 5.3c-3 2.8-3 7.5.0 10.2 2.8 3 7.5 3 10.5.0 2.8-2.8 2.8-7.5.0-10.2-3-3-7.7-3-10.5.0zm72.5-13.3c-19.9-14.4-33.8-43.2-11.9-68.1 21.6-24.9 40.7-17.2 59.8.8 11.9 11.3 29.3 24.9 17.2 48.2-12.5 23.5-45.1 33.2-65.1 19.1zm47.7-44.5c-8.9-10-23.3 6.9-15.5 16.1 7.4 9 32.1 2.4 15.5-16.1zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-66.2 42.6c2.5-16.1-20.2-16.6-25.2-25.7-13.6-24.1-27.7-36.8-54.5-30.4 11.6-8 23.5-6.1 23.5-6.1.3-6.4.0-13-9.4-24.9 3.9-12.5.3-22.4.3-22.4 15.5-8.6 26.8-24.4 29.1-43.2 3.6-31-18.8-59.2-49.8-62.8-22.1-2.5-43.7 7.7-54.3 25.7-23.2 40.1 1.4 70.9 22.4 81.4-14.4-1.4-34.3-11.9-40.1-34.3-6.6-25.7 2.8-49.8 8.9-61.4.0.0-4.4-5.8-8-8.9.0.0-13.8.0-24.6 5.3 11.9-15.2 25.2-14.4 25.2-14.4.0-6.4-.6-14.9-3.6-21.6-5.4-11-23.8-12.9-31.7 2.8.1-.2.3-.4.4-.5-5 11.9-1.1 55.9 16.9 87.2-2.5 1.4-9.1 6.1-13 10-21.6 9.7-56.2 60.3-56.2 60.3-28.2 10.8-77.2 50.9-70.6 79.7.3 3 1.4 5.5 3 7.5-2.8 2.2-5.5 5-8.3 8.3-11.9 13.8-5.3 35.2 17.7 24.4 15.8-7.2 29.6-20.2 36.3-30.4.0.0-5.5-5-16.3-4.4 27.7-6.6 34.3-9.4 46.2-9.1 8 3.9 8-34.3 8-34.3.0-14.7-2.2-31-11.1-41.5 12.5 12.2 29.1 32.7 28 60.6-.8 18.3-15.2 23-15.2 23-9.1 16.6-43.2 65.9-30.4 106 0 0-9.7-14.9-10.2-22.1-17.4 19.4-46.5 52.3-24.6 64.5 26.6 14.7 108.8-88.6 126.2-142.3 34.6-20.8 55.4-47.3 63.9-65 22 43.5 95.3 94.5 101.1 59z"/></svg><span class=menu-item-name>生活</span></a></li><li class=menu-item><a href=/tech/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tech"><path d="M512 256c0 141.2-114.7 256-256 256C114.8 512 0 397.3.0 256S114.7.0 256 0s256 114.7 256 256zm-32 0c0-123.2-100.3-224-224-224C132.5 32 32 132.5 32 256s100.5 224 224 224 224-100.5 224-224zM160.9 124.6l86.9 37.1-37.1 86.9-86.9-37.1 37.1-86.9zm110 169.1 46.6 94h-14.6l-50-1e2-48.9 1e2h-14l51.1-106.9-22.3-9.4 6-14 68.6 29.1-6 14.3-16.5-7.1zm-11.8-116.3 68.6 29.4-29.4 68.3L230 246l29.1-68.6zm80.3 42.9 54.6 23.1-23.4 54.3-54.3-23.1 23.1-54.3z"/></svg><span class=menu-item-name>技术</span></a></li><li class=menu-item><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon about"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6.0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7.0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4.0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9s28-2.7 40.9-6.9c2.3-.7 4.7-1.1 7.1-1.1 42.9.0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class=menu-item-name>述身</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=tech data-toc-num=true><h1 class="post-title p-name">Rust 核心语法：借用</h1><div class=post-meta><time datetime=2024-07-07T16:39:09+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2024.7.7</time>
<span class="post-meta-item category"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>&nbsp;<a href=/tech/ class="category-link p-category">TECH</a></span>
<span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;3223</span>
<span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;7&nbsp;分钟</span></div><nav class=contents><ol class=toc><li><a id=contents:引用 href=#引用>引用</a></li><li><a id=contents:解引用 href=#解引用>解引用</a></li><li><a id=contents:引用类型的所有权 href=#引用类型的所有权>引用类型的所有权</a></li><li><a id=contents:所有权树 href=#所有权树>所有权树</a></li><li><a id=contents:小结 href=#小结>小结</a></li><li><a id=contents:重借用 href=#重借用>重借用</a><ol><li><a id=contents:手写重借用 href=#手写重借用>手写重借用</a></li></ol></li></ol></nav><div class="post-body e-content"><h2 id=引用><a href=#引用 class=anchor-link>#</a><a href=#contents:引用 class=headings>引用</a></h2><p style=text-indent:0><span class=drop-cap>和</span> C/C++ 一样，Rust 有裸指针(Pointer)类型和引用(Reference)类型，分别是共享引用（不可变引用） <code>&amp;T</code> 和可变引用 <code>&amp;mut T</code>，常量裸指针（不可变指针） <code>*const T</code> 和可变裸指针 <code>*T</code>，他们的值都是 <code>T</code> 类型对象的地址，都可以通过解引用操作指向内存对象。</p><p>区别在于，Rust 认为裸指针是不安全的操作，所以它只能在 <code>unsafe</code> 块中使用，引用则是被编译器加了限制的裸指针，遵循借用规则(Borrowing Rules)并由编译器检查，以保证安全。</p><p>为了使用方便，Rust 引用的作用域比普通变量更短：普通变量的作用域从初始化持续到最近的花括号 <code>}</code>；引用的作用域从借用开始，一直持续到它最后一次使用的地方。这种优化行为被称为非词法作用域生命周期(Non-Lexical Lifetimes, NLL)。</p><p>创建一个引用的行为称为借用(Borrowing)，代表着引用会借用（而非获得）原变量对内存对象的所有权。当你只想使用变量，而不想转移所有权时，可以通过借用访问内存对象，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// s1 本质是一个指向堆内存的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>calculate_length</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s1</span><span class=p>);</span><span class=w> </span><span class=c1>// 发生了不可变借用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The length of &#39;</span><span class=si>{}</span><span class=s>&#39; is </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>calculate_length</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w> </span><span class=c1>// s 是指向 s1 的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>传入 <code>calculate_length()</code> 的是 <code>s1</code> 的共享引用，参数 <code>s</code> 会借用 <code>s1</code> 的所有权，如图所示：</p><p><img alt=2024-05-24-15-42-23.png src=/images/2024-05-24-15-42-23.png></p><p>Rust 的借用规则很有趣：</p><ol><li>在同一时刻，要么只有一个可变引用(<code>&amp;mut T</code>)，要么有任意数量的共享引用(<code>&amp;T</code>)。可变引用与共享引用不能同时存在，也不能同时存在多个可变引用。正因如此，可变引用 <code>&amp;mut T</code> 不能实现 <code>Copy</code>，这会违反借用规则。当然，共享引用是可 Copy 的，即把共享引用赋值给另一个共享引用后，可以继续使用</li><li>引用必须总是有效的，即引用的生命周期不能超过原变量的生命周期。所以当存在借用时，原变量不能 Move，但可以 Copy 或 Clone</li></ol><p>为什么会有这样的规定呢？因为 Rust 希望在同一时刻，<em class=emphasis-point>一份资源只能被至多一个变量名读写，或者被多个变量名读取</em>。由此：</p><ul><li>对于不可变借用(<code>let y = &amp;x</code>)：1)引用 <code>y</code> 是只读的；2)在 <code>y</code> 作用域结束之前，<code>x</code> 可读不可写（因为存在 <code>y</code> 可读），因此 <code>x</code> 能被不可变借用但不能被可变借用</li><li>对于可变借用(<code>let y = &amp;mut x</code>)：1)引用 <code>y</code> 可读写；2)在 <code>y</code> 作用域结束之前，<code>x</code> 不可读不可写（因为存在 <code>y</code> 可写），因此 <code>x</code> 不能再次被借用</li></ul><p>下面这段代码会报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w> </span><span class=c1>// y 可变借用于 x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 报错：存在 x 的可变引用 y，此时不能通过原变量 x 读取值（也不可写入值）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=o>*</span><span class=n>y</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>// y 的作用域到此结束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=c1>// x 可以正常读取
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=解引用><a href=#解引用 class=anchor-link>#</a><a href=#contents:解引用 class=headings>解引用</a></h2><p>解引用操作 <code>*r</code> 会得到一个被称为影子变量的东西，可以理解为没有所有权的变量别名。它可以用来对内存对象进行读写，但不能通过它转移所有权（但可以 Copy 或 Clone），这会影响本体对于内存对象的掌控：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyType</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>val</span>: <span class=nc>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>num1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>num1_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>num1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// i32 类型实现了 Copy，因此 i32 类型的影子变量会进行 Copy 操作，这不会影响本体的所有权
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>num2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>num1_ref</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MyType</span><span class=p>{</span><span class=n>val</span>: <span class=mi>1</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这里报错，因为无法通过解引用得到的影子变量移动所有权
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>y</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=引用类型的所有权><a href=#引用类型的所有权 class=anchor-link>#</a><a href=#contents:引用类型的所有权 class=headings>引用类型的所有权</a></h2><p>Rust 中所有的值都有所有权，引用类型的值也不例外。引用不拥有指向对象的所有权，但引用变量拥有自身地址值的所有权。参考下面这段代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;value&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w> </span><span class=c1>// r 是 s 的可变引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w> </span><span class=c1>// move 而非 copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 报错 borrow of moved value: `r`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上文提到，共享引用实现了 <code>Copy</code>，自然也实现了 <code>Clone</code>，而下面的结构体 <code>Person</code> 没有实现 <code>Clone</code>，因此 <code>b.clone()</code> 只能复制引用 <code>b</code>，不能复制引用指向的内存对象。虽然这能通过编译，但 clippy 不建议我们这样做，因为它的行为相当于 <code>Copy</code> 操作，很可能不是我们希望的克隆效果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Person</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Person</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>  </span><span class=c1>// c 的类型是 &amp;Person
</span></span></span></code></pre></div><p>但如果为结构体 <code>Person</code> 实现 <code>Clone</code>，再去 <code>clone()</code> 引用类型，将没有错误提示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Person</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Person</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>  </span><span class=c1>// 此时 c 的类型是 Person，而不是 &amp;Person
</span></span></span></code></pre></div><p>前后两个示例的区别，仅在于引用所指向的类型 <code>Person</code> 有没有实现 <code>Clone</code>。所以得出结论：</p><ul><li>没有实现 <code>Clone</code> 时，引用类型的 <code>clone()</code> 将等价于 Copy</li><li>实现了 <code>Clone</code> 时，引用类型的 <code>clone()</code> 将克隆并得到引用所指向的类型</li></ul><p>这是因为，方法调用时会先查找与调用者类型匹配的方法，查找过程具有优先级，找到即停。由于 <code>.</code> 操作可以自动引用/解引用，如果引用/解引用前后的两种类型都实现了同一方法(如 <code>clone()</code>)，Rust 编译器将按照查找顺序来决定调用哪个类型上的方法。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>[1]</a></sup></p><p>如果 <code>b</code> 是没有实现 <code>Copy</code> 和 <code>Clone</code> 的可变引用，<code>b.clone()</code> 只能得到 <code>Person</code> 类型（前提是 <code>Person</code> 实现了 <code>Clone</code>）。</p><h2 id=所有权树><a href=#所有权树 class=anchor-link>#</a><a href=#contents:所有权树 class=headings>所有权树</a></h2><p>Rust 每个拥有所有权的容器类型(<code>tuple</code>/<code>array</code>/<code>vec</code>/<code>struct</code>/<code>enum</code>等)变量和它的成员（以及成员的成员），会形成一棵所有权树。树中任何一个成员（假设叫 <code>A</code>）离开作用域或转移所有权，其全部子成员将与其保持行为一致——销毁内存对象或 Move 给新变量。</p><p>当成员 <code>A</code> 所有权转移后，除非你为 <code>A</code> 重新初始化，否则 <code>A</code> 的所有父成员（包括树的根成员）将失去所有权（但不属于 <code>A</code> 子成员的仍然可用）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tup</span><span class=p>;</span><span class=w> </span><span class=c1>// tup.1 转移所有权给 y，tup.0 copy 给 x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>,</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w> </span><span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>tup</span><span class=p>.</span><span class=mi>0</span><span class=p>);</span><span class=w> </span><span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// tup.1 = String::from(&#34;world&#34;); // 重新初始化 tup 可以修正错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>tup</span><span class=p>.</span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=c1>// 错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>tup</span><span class=p>);</span><span class=w> </span><span class=c1>// 错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=小结><a href=#小结 class=anchor-link>#</a><a href=#contents:小结 class=headings>小结</a></h2><p>这张图展示了变量、类型、内存对象、值，引用、解引用和裸指针的概念：</p><p><img alt=2024-05-24-17-17-25.png src=/images/2024-05-24-17-17-25.png></p><h2 id=重借用><a href=#重借用 class=anchor-link>#</a><a href=#contents:重借用 class=headings>重借用</a></h2><p>上文提到，借用检查不允许对一个实例的多个可变引用，也不能同时存在共享和可变引用。但对解引用得到的影子变量进行借用（重借用）却是可行的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;ABC&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=n>r1</span><span class=p>;</span><span class=w> </span><span class=c1>// 重借用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>r2</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;2&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r2</span><span class=p>);</span><span class=w> </span><span class=c1>// r2 的作用域到此结束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>);</span><span class=w> </span><span class=c1>// r1 的作用域到此结束
</span></span></span></code></pre></div><p>这段代码的大括号内，同时存在 <code>r1</code> <code>r2</code> 两个指向同一变量 <code>s</code> 的可变引用，但编译器不会报错。这是因为编译器看到 <code>*r1</code> 的时候，通常很难确定解引用得到的实际对象是什么，所以借用检查不会把 <code>*r1</code> 跟 <code>s</code> 当成同一个对象，自然不会报错。</p><p>关于重借用，唯一的限制是不能在 <code>r2</code> 的生命周期中使用 <code>r1</code>，这样就不会违反借用规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;ABC&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=n>r1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w> </span><span class=c1>// 错误 Cannot borrow `*r1` as immutable because it is also borrowed as mutable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>l</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>r2</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;2&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>r1</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;3&#39;</span><span class=p>);</span><span class=w> </span><span class=c1>// 错误 Cannot borrow `*r1` as mutable more than once at a time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>);</span><span class=w> </span><span class=c1>// 错误 Cannot borrow `r1` as immutable because it is also borrowed as mutable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>你可能会好奇，明明传入方法的是引用类型，为什么前两条报错信息中会显示 <code>*r1</code>？这是因为发生了隐式重借用，<code>r1.len()</code> 实际上是 <code>String::len(&*r1)</code>，同理 <code>r1.push('3')</code> 实际上是 <code>String::push(&amp;mut *r1, '3')</code>。</p><p>隐式重借用并非多此一举，<code>len()</code> 和 <code>push()</code> 的方法签名分别是 <code>pub fn len(&amp;self) -> usize</code> 和 <code>pub fn push(&amp;mut self, ch: char)</code>。没有隐式重借用，可变引用 <code>r1</code> 将无法调用 <code>len()</code>，而 <code>r1.push('3')</code> 会转移可变引用 <code>r1</code> 的所有权，导致 <code>r1</code> 之后无法使用。</p><p>事实上，隐式重借用几乎无处不在：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;ABC&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 不标注 r2 的类型，会 Move 而非隐式重借用，之后 r1 失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 手动标注 r2 的类型，会进行非隐式重借用，函数传参同理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>r3</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>String</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r2</span><span class=p>;</span><span class=w> </span><span class=c1>// 相当于 let r3: &amp;mut String = &amp;mut *r2;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r2</span><span class=p>);</span><span class=w> </span><span class=c1>// 打印 r3 r2 的顺序不能颠倒
</span></span></span></code></pre></div><p>对共享引用 <code>&amp;T</code>，可以认为发生了重借用, 也可以认为直接发生 <code>Copy</code>，因为效果完全一样。</p><h3 id=手写重借用><a href=#手写重借用 class=anchor-link>#</a><a href=#contents:手写重借用 class=headings>手写重借用</a></h3><p>下面这两种情况<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>[2]</a></sup>，<code>from()</code> 函数不会自动重借用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>X</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>i</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>X</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>from_auto_reborrow</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nb>From</span><span class=o>&lt;&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>F</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>mut</span><span class=w> </span><span class=n>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>::<span class=n>from</span><span class=p>(</span><span class=n>f</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=nc>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from_auto_reborrow</span><span class=p>(</span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 可以自动重借用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=nc>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from_auto_reborrow</span><span class=p>(</span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 可以自动重借用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>from</span><span class=o>&lt;</span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nb>From</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>::<span class=n>from</span><span class=p>(</span><span class=n>f</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=nc>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 必须显式重借用, 创建 x 的 reborrow 不会 move x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=nc>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from</span><span class=p>(</span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 此处不会自动重借用, 导致 Move x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=nc>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from</span><span class=p>(</span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译失败
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>I</span><span class=p>(</span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>X1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>I</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>X1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>X1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 必须引入这个中间函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>x1</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>X1</span>::<span class=n>from</span><span class=p>(</span><span class=n>p</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// value used here after move
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>from_twice_fail</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>I</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x11</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>X1</span>::<span class=n>from</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=w> </span><span class=c1>// p Move
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x12</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>X1</span>::<span class=n>from</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译失败
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>from_twice</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>I</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x11</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x1</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=w> </span><span class=c1>// 此处不会自动重借用, 导致 Move p
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x12</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x1</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>参考：<a href="https://rustc-dev-guide.rust-lang.org/method-lookup.html?highlight=lookup#method-lookup" target=_blank rel=noopener>https://rustc-dev-guide.rust-lang.org/method-lookup.html?highlight=lookup#method-lookup</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>参考：<a href="https://rustcc.cn/article?id=28fedcbc-d0c9-41e1-8d95-de73a578a078" target=_blank rel=noopener>https://rustcc.cn/article?id=28fedcbc-d0c9-41e1-8d95-de73a578a078</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><div class=updated-badge-container><span title="Updated @ 2024-07-07 16:44:56 CST" style=cursor:help><svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2024-07-07</text><text x="915" y="140" textLength="650" transform="scale(.1)">2024-07-07</text></g></svg></span></div><footer class=minimal-footer><div class=post-tag><a href=/tags/rust/ rel=tag class=post-tag-link>#rust</a></div><div class=post-category><a href=/tech/ class="post-category-link active">tech</a> | <a href=/life/ class=post-category-link>life</a></div></footer></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div></div><script>"serviceWorker"in navigator&&window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")})</script><script src=/libs/medium-zoom.min.js></script><script>let imgNodes=document.querySelectorAll("div.post-body img");imgNodes=Array.from(imgNodes).filter(e=>e.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script></body></html>